"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[1969],{8453(e,n,s){s.d(n,{R:()=>r,x:()=>a});var i=s(6540);const o={},t=i.createContext(o);function r(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(t.Provider,{value:n},e.children)}},9323(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"chapter_1_ros2_overview","title":"Introduction to ROS 2","description":"What is ROS 2?","source":"@site/docs/chapter_1_ros2_overview.md","sourceDirName":".","slug":"/chapter_1_ros2_overview","permalink":"/ai-book/docs/chapter_1_ros2_overview","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter_1_ros2_overview.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Physical AI & Humanoid Robotics: Course Overview","permalink":"/ai-book/docs/course-overview"},"next":{"title":"Bridging Python Agents to ROS Controllers","permalink":"/ai-book/docs/chapter_2_rclpy_python_agents"}}');var o=s(4848),t=s(8453);const r={},a="Introduction to ROS 2",c={},l=[{value:"What is ROS 2?",id:"what-is-ros-2",level:2},{value:"Key Concepts in ROS 2",id:"key-concepts-in-ros-2",level:3},{value:"Nodes, Topics, and Services",id:"nodes-topics-and-services",level:2},{value:"Nodes",id:"nodes",level:3},{value:"Topics",id:"topics",level:3},{value:"Services",id:"services",level:3},{value:"Middleware Role in Humanoid Robotics",id:"middleware-role-in-humanoid-robotics",level:2},{value:"Communication Infrastructure",id:"communication-infrastructure",level:3},{value:"Distributed Architecture Benefits",id:"distributed-architecture-benefits",level:3},{value:"Example Humanoid ROS 2 Architecture",id:"example-humanoid-ros-2-architecture",level:3}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"introduction-to-ros-2",children:"Introduction to ROS 2"})}),"\n",(0,o.jsx)(n.h2,{id:"what-is-ros-2",children:"What is ROS 2?"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 (Robot Operating System 2) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms."}),"\n",(0,o.jsx)(n.p,{children:"Unlike traditional operating systems, ROS 2 is not an actual operating system but rather a middleware framework that provides services designed for a heterogeneous computer cluster. It includes hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more."}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 is the next generation of the Robot Operating System, addressing many limitations of the original ROS, including:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Real-time support"}),": ROS 2 provides real-time capabilities that were missing in the original ROS"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Deterministic behavior"}),": More predictable performance characteristics"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Improved security"}),": Built-in security features for communication"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Better architecture"}),": More modular design allowing for different communication middleware"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Official Windows support"}),": Unlike ROS 1 which was primarily Linux-focused"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"key-concepts-in-ros-2",children:"Key Concepts in ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 is built around several core concepts that work together to enable distributed robot applications:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Nodes"}),": Processes that perform computation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Topics"}),": Named buses over which nodes exchange messages"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Services"}),": Synchronous request/response communication"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actions"}),": Asynchronous request/goal-based communication"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Parameters"}),": Configuration values that nodes can store and retrieve"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"nodes-topics-and-services",children:"Nodes, Topics, and Services"}),"\n",(0,o.jsx)(n.h3,{id:"nodes",children:"Nodes"}),"\n",(0,o.jsx)(n.p,{children:"A node is a process that performs computation. In ROS 2, nodes are designed to be as lightweight as possible. A properly designed system should have many nodes, each performing a discrete task. For example, you might have one node that controls a laser range-finder, another that performs localization, and another that provides a user interface."}),"\n",(0,o.jsx)(n.p,{children:"Nodes are organized into packages for distribution, and you can run multiple nodes from a single package, or multiple nodes from multiple packages. You can even run multiple instances of the same node."}),"\n",(0,o.jsx)(n.h3,{id:"topics",children:"Topics"}),"\n",(0,o.jsx)(n.p,{children:"Topics are named buses over which nodes exchange messages. This communication is based on a publish/subscribe pattern where nodes can publish messages to a topic and/or subscribe to a topic to receive messages. This means that a single node can publish to multiple topics, and subscribe to multiple topics. Multiple nodes can also subscribe to the same topic, and multiple nodes can publish to the same topic."}),"\n",(0,o.jsx)(n.p,{children:"The publish/subscribe pattern is a very flexible communication paradigm, but it does have limitations. The most significant is that there is no confirmation that messages have been delivered, and no way to know if there are any subscribers to a topic."}),"\n",(0,o.jsx)(n.h3,{id:"services",children:"Services"}),"\n",(0,o.jsx)(n.p,{children:"Services provide a request/response communication pattern, which is synchronous. A node offering a service will wait for a request from another node, process the request, and send back a response. This is different from the publish/subscribe pattern, which is asynchronous."}),"\n",(0,o.jsx)(n.p,{children:"Services are useful when you need to know that your request was processed, or when you need to wait for a specific response before continuing. However, they block the requesting node until the response is received, which may not be suitable for all applications."}),"\n",(0,o.jsx)(n.h2,{id:"middleware-role-in-humanoid-robotics",children:"Middleware Role in Humanoid Robotics"}),"\n",(0,o.jsx)(n.h3,{id:"communication-infrastructure",children:"Communication Infrastructure"}),"\n",(0,o.jsx)(n.p,{children:"In humanoid robotics, ROS 2 serves as the communication infrastructure that allows different components of the robot to work together. A humanoid robot typically has:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensors"}),": Cameras, IMUs, force/torque sensors, joint encoders"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actuators"}),": Motors controlling joints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Processing units"}),": Computers running perception, planning, and control algorithms"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interfaces"}),": Human-robot interaction components"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 provides the middleware that allows these components to communicate seamlessly, regardless of the programming language they're written in or the computers they're running on."}),"\n",(0,o.jsx)(n.h3,{id:"distributed-architecture-benefits",children:"Distributed Architecture Benefits"}),"\n",(0,o.jsx)(n.p,{children:"The distributed architecture of ROS 2 is particularly beneficial for humanoid robots because:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modularity"}),": Different robot functions can be developed and tested independently"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Scalability"}),": New sensors or actuators can be added without disrupting existing functionality"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Fault tolerance"}),": If one component fails, others can continue operating"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Development efficiency"}),": Multiple teams can work on different components simultaneously"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-humanoid-ros-2-architecture",children:"Example Humanoid ROS 2 Architecture"}),"\n",(0,o.jsx)(n.p,{children:"A typical humanoid robot using ROS 2 might have these nodes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor nodes"}),": Publish sensor data (camera images, IMU readings, joint positions)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Perception nodes"}),": Process sensor data to detect objects, recognize speech, etc."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Planning nodes"}),": Generate motion plans based on goals and sensor data"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Control nodes"}),": Send commands to actuators to execute motions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interface nodes"}),": Handle communication with humans (speech, gestures)"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"All these nodes communicate through ROS 2 topics and services, creating a cohesive system where each component can be developed, tested, and maintained independently."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);